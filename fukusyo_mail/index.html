<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>福岡市 直近24時間の防災情報マップ & テーブル（リファクタリング版）</title>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Leaflet.js CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  
  <!-- MarkerCluster CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css"/>

  <style>
    /* Leafletのコンテナに高さを設定するために必要 */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden; /* ページ全体のスクロールを禁止 */
    }
    #app-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #main-content {
      flex-grow: 1;
      display: flex;
      min-height: 0; /* flexアイテムの縮小を許可 */
    }
    #map {
      height: 100%;
      width: 100%;
      z-index: 0;
    }
    /* テーブルのヘッダーを固定 */
    #table-container thead th {
      position: sticky;
      top: 0;
      z-index: 1;
    }
    /* クリック可能な行のカーソルを変更 */
    #data-table tbody tr[data-id] {
      cursor: pointer;
    }
  </style>
</head>

<body class="bg-gray-100 font-sans">

  <div id="app-container">
    <header class="bg-white shadow-md p-4 text-center z-10">
      <h1 class="text-xl md:text-2xl font-bold text-gray-800">福岡市 直近24時間の防災情報マップ</h1>
    </header>

    <div id="main-content" class="flex-col md:flex-row">
      <!-- Map Container -->
      <div id="map-container" class="flex-1 relative">
	<div id="map"></div>
	<div id="status" class="absolute top-4 left-1/2 -translate-x-1/2 bg-white/90 p-2 px-4 rounded-full shadow-lg text-sm text-gray-700 z-[1000] transition-opacity duration-300">
	  データを読み込み中...
	</div>
      </div>

      <!-- Table Container -->
      <div id="table-container" class="w-full md:w-2/5 lg:w-1/3 h-1/2 md:h-full overflow-y-auto bg-white border-t md:border-t-0 md:border-l border-gray-200">
	<table id="data-table" class="w-full text-sm">
	  <thead class="bg-gray-100">
	    <tr>
	      <th class="p-2 text-left font-semibold text-gray-600">受信日時</th>
	      <th class="p-2 text-left font-semibold text-gray-600">災害種別</th>
	      <th class="p-2 text-left font-semibold text-gray-600">連結住所</th>
	    </tr>
	  </thead>
	  <tbody>
	    <!-- Data will be inserted here -->
	  </tbody>
	</table>
      </div>
    </div>
  </div>

  <!-- Leaflet.js -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <!-- MarkerCluster JS -->
  <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>

  <script>
    // --- 設定値 ---
    const CONFIG = {
        FUKUOKA_CITY_CENTER: [33.5903, 130.4017],
        INITIAL_ZOOM: 12,
        CKAN_RESOURCE_ID: '6c67e16b-9e5c-473b-838c-09760b8bcf1f',
        CKAN_API_BASE_URL: 'https://data.bodik.jp/api/3/action/',
        GSI_GEOCODE_URL: 'https://msearch.gsi.go.jp/address-search/AddressSearch?q=',
        COLOR_MAP: {
            '救助': '#007bff',
            '救急': '#28a745',
            '火災': '#dc3545',
            '警戒': '#fd7e14',
            '応援': '#6f42c1',
            'その他': '#6c757d'
        },
        RETRY_COUNT: 3,
        RETRY_DELAY: 500, // ms
    };

    // --- DOM要素 ---
    const DOMElements = {
        map: document.getElementById('map'),
        status: document.getElementById('status'),
        tableBody: document.querySelector('#data-table tbody'),
    };

    // --- Leafletの初期化 ---
    const map = L.map(DOMElements.map).setView(CONFIG.FUKUOKA_CITY_CENTER, CONFIG.INITIAL_ZOOM);
    L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/pale/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">地理院タイル</a>',
	maxZoom: 18,
    }).addTo(map);
    const markers = L.markerClusterGroup({ chunkedLoading: true });
    const markersMap = new Map(); // マーカーをIDで管理するためのMap

    /**
     * ステータスメッセージを更新し、一定時間後に非表示にする
     * @param {string} text - 表示するテキスト
     * @param {boolean} [hideAfter=false] - 一定時間後に非表示にするか
     */
    function updateStatus(text, hideAfter = false) {
        DOMElements.status.textContent = text;
	DOMElements.status.style.opacity = 1;
	if (hideAfter) {
	    setTimeout(() => {
	        DOMElements.status.style.opacity = 0;
	    }, 3000);
	}
    }

    /**
     * CKANから防災情報をJSONPを使って非同期で取得する
     * @returns {Promise<Array>} - 災害情報のレコード配列
     */
    function fetchDisasterData() {
        updateStatus('防災データを取得中...');
	return new Promise((resolve, reject) => {
	    const callbackName = `handleCkanResponse_${Date.now()}`;

	    window[callbackName] = (data) => {
	        try {
		    if (!data.success) throw new Error('CKAN APIが失敗を返しました。');
		    const allRecords = data.result.records || [];
		    const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);

		    const filteredRecords = allRecords.filter(rec => {
		        if (!rec.受信日時) return false;
			return new Date(rec.受信日時) > twentyFourHoursAgo;
		    });

		    resolve(filteredRecords);

		} catch (error) {
		    reject(error);
		} finally {
		    try {
		        delete window[callbackName];
			document.getElementById('ckan-jsonp-script')?.remove();
		    } catch (e) {
		        console.warn("Callback cleanup failed.", e);
		    }
		}
	    };

	    const sortParam = encodeURIComponent('受信日時 desc');
	    const limit = 100;
	    const url = `${CONFIG.CKAN_API_BASE_URL}datastore_search?resource_id=${CONFIG.CKAN_RESOURCE_ID}&limit=${limit}&sort=${sortParam}&callback=${callbackName}`;

	    const script = document.createElement('script');
	    script.id = 'ckan-jsonp-script';
	    script.src = url;
	    script.onerror = () => {
	        reject(new Error('CKAN APIのスクリプト読み込みに失敗しました。'));
		delete window[callbackName];
		script.remove();
	    };
	    document.body.appendChild(script);
	});
    }

    /**
     * 国土地理院のAPIで住所をジオコーディングする（リトライ機能付き）
     * @param {string} address - ジオコーディングする住所
     * @returns {Promise<[number, number]>} - [緯度, 経度] の配列
     */
    async function geocodeAddress(address) {
        const url = `${CONFIG.GSI_GEOCODE_URL}${encodeURIComponent(address)}`;
	let lastError;
	for (let i = 0; i < CONFIG.RETRY_COUNT; i++) {
	    try {
	        const response = await fetch(url);
		if (!response.ok) throw new Error(`HTTPエラー ${response.status}`);
		const data = await response.json();
		if (Array.isArray(data) && data.length > 0 && data[0].geometry) {
		    const [lon, lat] = data[0].geometry.coordinates;
		    return [lat, lon];
		}
		throw new Error('有効な座標が見つかりませんでした');
	    } catch (error) {
	        lastError = error;
		await new Promise(resolve => setTimeout(resolve, CONFIG.RETRY_DELAY * (i + 1)));
	    }
	}
	throw lastError;
    }

    /**
     * レコードを処理し、マップとテーブルを更新する
     * @param {Array} records - 災害情報のレコード配列
     */
    async function processAndRenderData(records) {
        records.sort((a, b) => new Date(b.受信日時) - new Date(a.受信日時));

	if (records.length === 0) {
	    updateStatus('直近24時間の該当データはありませんでした。', true);
	    return;
	}

	updateStatus(`ジオコーディング中... (0/${records.length})`);
	markersMap.clear(); // 新しいデータを処理する前にクリア

	const geocodePromises = records.map(rec => {
	    const parts = ['福岡県', '福岡市', rec.区, rec.町, rec.丁目, rec.番].filter(Boolean);
	    const address = parts.join('');
	    return geocodeAddress(address)
	        .then(coords => ({ rec, address, coords, status: 'fulfilled' }))
		.catch(error => ({ rec, address, error, status: 'rejected' }));
	});

	const results = await Promise.all(geocodePromises);

	let tableRowsHtml = '';
	const validMarkers = [];
	let firstValidCoords = null;
	let processedCount = 0;

	for (const result of results) {
	    processedCount++;
	    updateStatus(`データを処理中... (${processedCount}/${records.length})`);

	    const { rec, address } = result;
	    const disasterType = rec.災害種別 || 'その他';
	    const receivedAt = rec.受信日時 || '';
	    const id = rec._id;

	    let rowAttributes = 'class="border-b border-gray-200 hover:bg-gray-50"';

	    if (result.status === 'fulfilled') {
		const { coords } = result;
		if (!firstValidCoords) firstValidCoords = coords;

		rowAttributes += ` data-id="${id}"`;

		const marker = L.circleMarker(coords, {
		    radius: 8,
		    fillColor: CONFIG.COLOR_MAP[disasterType] || CONFIG.COLOR_MAP['その他'],
		    color: '#000', weight: 1, opacity: 1, fillOpacity: 0.8
		}).bindPopup(`
		            <strong class="text-base">${disasterType}</strong><hr class="my-1">
			                <strong>受信日時:</strong><br>${receivedAt}<br>
					            <strong>連結住所:</strong><br>${address}
						              `);
		validMarkers.push(marker);
		markersMap.set(id, marker); // マーカーをIDと共に保存
	    } else {
	        console.warn(`ジオコーディング失敗: ${address}`, result.error);
	    }

	    tableRowsHtml += `
	              <tr ${rowAttributes}>
		                  <td class="p-2">${receivedAt}</td>
				              <td class="p-2">
					                    <span class="px-2 py-1 text-xs font-semibold rounded-full" style="background-color:${CONFIG.COLOR_MAP[disasterType] || CONFIG.COLOR_MAP['その他']}; color: white;">
																									                    ${disasterType}
																											                  </span>
																													              </td>
																														                  <td class="p-2">${address}</td>
																																            </tr>
																																	            `;
	}

	DOMElements.tableBody.innerHTML = tableRowsHtml;
	markers.clearLayers();
	markers.addLayers(validMarkers);
	map.addLayer(markers);

	if (firstValidCoords) {
	    map.setView(firstValidCoords, map.getZoom());
	}

	updateStatus(`完了: ${records.length}件中${validMarkers.length}件を表示しました。`, true);
    }

    /**
     * アプリケーションを初期化して実行するメイン関数
     */
    async function main() {
        try {
	    const records = await fetchDisasterData();
	    await processAndRenderData(records);
	} catch (error) {
	    console.error('処理中にエラーが発生しました:', error);
	    updateStatus(`エラー: ${error.message}`, true);
	}
    }

    // --- イベントリスナー ---
    DOMElements.tableBody.addEventListener('click', (event) => {
	const row = event.target.closest('tr');
	if (!row || !row.dataset.id) return;

	const id = parseInt(row.dataset.id, 10);
	const marker = markersMap.get(id);

	if (marker) {
	    // マーカーがクラスター内にある場合も考慮してズームし、ポップアップを開く
	    markers.zoomToShowLayer(marker, () => {
	        marker.openPopup();
	    });
	}
    });

    // アプリケーション実行
    main();

    </script>
</body>
</html>
